use std::time::Duration;

use alloy_rlp::Encodable;
use alloy_rpc_client::ReqwestClient;
use alloy_sol_macro::sol;
use alloy_sol_types::SolCall;
use eyre::Result;
use reth_primitives::{
    hex::FromHex, keccak256, AccessList, Address, Bytes, Transaction, TransactionKind,
    TransactionSigned, TxEip1559, U256,
};
use serde::Deserialize;
use serde_json::{json, Value};
use tokio::time::sleep;
use tracing::info;

use crate::{shared::json_rpc::JsonRpc, shared::private_key::PrivateKey};

const BYTECODE: &str = "0x608060405234801561001057600080fd5b50604080518082019091526009815268115490cc8c15195cdd60ba1b602082015260039061003e9082610118565b5060408051808201909152600381526209090960ea1b60208201526004906100669082610118565b506005805460ff191660121790556101d6565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806100a357607f821691505b6020821081036100c357634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561011357806000526020600020601f840160051c810160208510156100f05750805b601f840160051c820191505b8181101561011057600081556001016100fc565b50505b505050565b81516001600160401b0381111561013157610131610079565b6101458161013f845461008f565b846100c9565b6020601f82116001811461017957600083156101615750848201515b600019600385901b1c1916600184901b178455610110565b600084815260208120601f198516915b828110156101a95787850151825560209485019460019092019101610189565b50848210156101c75786840151600019600387901b60f8161c191681555b50505050600190811b01905550565b61073c806101e56000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c806340c10f191161007157806340c10f191461014d57806370a082311461016057806395d89b41146101805780639dc29fac14610188578063a9059cbb1461019b578063dd62ed3e146101ae57600080fd5b806306fdde03146100b9578063095ea7b3146100d75780631249c58b146100fa57806318160ddd1461010457806323b872dd1461011b578063313ce5671461012e575b600080fd5b6100c16101d9565b6040516100ce919061054a565b60405180910390f35b6100ea6100e53660046105b4565b610267565b60405190151581526020016100ce565b6101026102d4565b005b61010d60005481565b6040519081526020016100ce565b6100ea6101293660046105de565b6102e2565b60055461013b9060ff1681565b60405160ff90911681526020016100ce565b61010261015b3660046105b4565b6103bd565b61010d61016e36600461061b565b60016020526000908152604090205481565b6100c16103cb565b6101026101963660046105b4565b6103d8565b6100ea6101a93660046105b4565b6103e2565b61010d6101bc36600461063d565b600260209081526000928352604080842090915290825290205481565b600380546101e690610670565b80601f016020809104026020016040519081016040528092919081815260200182805461021290610670565b801561025f5780601f106102345761010080835404028352916020019161025f565b820191906000526020600020905b81548152906001019060200180831161024257829003601f168201915b505050505081565b3360008181526002602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925906102c29086815260200190565b60405180910390a35060015b92915050565b6102e033612710610460565b565b6001600160a01b03831660009081526002602090815260408083203384529091528120805483919083906103179084906106c0565b90915550506001600160a01b038416600090815260016020526040812080548492906103449084906106c0565b90915550506001600160a01b038316600090815260016020526040812080548492906103719084906106d3565b92505081905550826001600160a01b0316846001600160a01b03166000805160206106e7833981519152846040516103ab91815260200190565b60405180910390a35060019392505050565b6103c78282610460565b5050565b600480546101e690610670565b6103c782826104d9565b336000908152600160205260408120805483919083906104039084906106c0565b90915550506001600160a01b038316600090815260016020526040812080548492906104309084906106d3565b90915550506040518281526001600160a01b0384169033906000805160206106e7833981519152906020016102c2565b6001600160a01b038216600090815260016020526040812080548392906104889084906106d3565b92505081905550806000808282546104a091906106d3565b90915550506040518181526001600160a01b038316906000906000805160206106e7833981519152906020015b60405180910390a35050565b6001600160a01b038216600090815260016020526040812080548392906105019084906106c0565b925050819055508060008082825461051991906106c0565b90915550506040518181526000906001600160a01b038416906000805160206106e7833981519152906020016104cd565b602081526000825180602084015260005b81811015610578576020818601810151604086840101520161055b565b506000604082850101526040601f19601f83011684010191505092915050565b80356001600160a01b03811681146105af57600080fd5b919050565b600080604083850312156105c757600080fd5b6105d083610598565b946020939093013593505050565b6000806000606084860312156105f357600080fd5b6105fc84610598565b925061060a60208501610598565b929592945050506040919091013590565b60006020828403121561062d57600080fd5b61063682610598565b9392505050565b6000806040838503121561065057600080fd5b61065983610598565b915061066760208401610598565b90509250929050565b600181811c9082168061068457607f821691505b6020821081036106a457634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052601160045260246000fd5b818103818111156102ce576102ce6106aa565b808201808211156102ce576102ce6106aa56feddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa26469706673582212204bf297272be1c921a67e2846b7903d830dadbf1c14acba4ee8bfae2841ff415464736f6c634300081a0033";

#[derive(Deserialize, Debug, Clone, Copy)]
#[serde(transparent)]
pub struct ERC20 {
    pub addr: Address,
}

impl ERC20 {
    pub async fn deploy(deployer: &(Address, PrivateKey), client: ReqwestClient) -> Result<Self> {
        let nonce = client.get_transaction_count(&deployer.0).await?;
        let input = Bytes::from_hex(BYTECODE)?;
        let tx = Transaction::Eip1559(TxEip1559 {
            chain_id: 41454,
            nonce,
            gas_limit: 4_000_000, // usually around 600k gas
            max_fee_per_gas: 100_000,
            max_priority_fee_per_gas: 10,
            to: TransactionKind::Create,
            value: U256::ZERO.into(),
            access_list: AccessList::default(),
            input: input.into(),
        });

        let sig = deployer.1.sign_transaction(&tx);
        let tx = TransactionSigned::from_transaction_and_signature(tx, sig);

        // make compiler happy, actually parse string : (
        let _: String = client
            .request("eth_sendRawTransaction", [tx.envelope_encoded()])
            .await?;

        sleep(Duration::from_secs(1)).await;

        let addr = calculate_contract_addr(&deployer.0, nonce);
        info!(addr = addr.to_string(), "Deployed erc20 contract");
        Ok(Self { addr })
    }

    pub fn construct_mint(&self, from: &PrivateKey, nonce: u64) -> TransactionSigned {
        let input = IERC20::mintCall {}.abi_encode();
        let tx = Transaction::Eip1559(TxEip1559 {
            chain_id: 41454,
            nonce,
            gas_limit: 400_000, // probably closer to 80k
            max_fee_per_gas: 100_000,
            max_priority_fee_per_gas: 10,
            to: TransactionKind::Call(self.addr.clone()),
            value: U256::ZERO.into(),
            access_list: AccessList::default(),
            input: input.into(),
        });
        let sig = from.sign_transaction(&tx);
        TransactionSigned::from_transaction_and_signature(tx, sig)
    }

    pub fn construct_transfer(
        &self,
        from: &PrivateKey,
        recipient: Address,
        nonce: u64,
        amount: U256,
    ) -> TransactionSigned {
        let input = IERC20::transferCall { recipient, amount }.abi_encode();
        let tx = Transaction::Eip1559(TxEip1559 {
            chain_id: 41454,
            nonce,
            gas_limit: 400_000, // probably closer to 80k
            max_fee_per_gas: 100_000,
            max_priority_fee_per_gas: 10,
            to: TransactionKind::Call(self.addr.clone()),
            value: U256::ZERO.into(),
            access_list: AccessList::default(),
            input: input.into(),
        });
        let sig = from.sign_transaction(&tx);
        TransactionSigned::from_transaction_and_signature(tx, sig)
    }

    pub fn balance_of(&self, account: Address) -> (&'static str, [Value; 1]) {
        let input = IERC20::balanceOfCall { account };
        let call = json!({
            "to": self.addr,
            "data": input.abi_encode()
        });
        ("eth_call", [call])
    }
}

// struct Contract {
//     pub addr: Address,
//     pub client: ReqwestClient,
// }

// impl Contract {
//     pub async fn call<R: RpcReturn, T: alloy_sol_types::SolCall>(&self, input: T) -> Result<R> {
//         let call = json!({
//             "to": self.addr,
//             "data": input.abi_encode()
//         });

//         let x = self.client.request::<_, R>("eth_call", [call]).await?;
//         Ok(x)
//     }
// }

pub fn calculate_contract_addr(deployer: &Address, nonce: u64) -> Address {
    let mut out = Vec::new();
    let enc: [&dyn Encodable; 2] = [&deployer, &nonce];
    alloy_rlp::encode_list::<_, dyn Encodable>(&enc, &mut out);
    let hash = keccak256(out);
    let (_, contract_address) = hash.as_slice().split_at(12);
    Address::from_slice(contract_address)
}

sol! {
pragma solidity ^0.8.13;

contract IERC20 {
    // constructor(string memory _name, string memory _symbol, uint8 _decimals);

    function mint() external;
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}}
